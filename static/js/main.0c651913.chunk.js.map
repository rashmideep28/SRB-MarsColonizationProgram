{"version":3,"sources":["PathfinderVisualizer/Node/Node.jsx","Algorithms/Dijkstras.js","Algorithms/A_star.js","PathfinderVisualizer/PathfinderVisualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["Node","this","props","col","isFinish","isStart","isWall","whileMousePressed","onMouseEnter","onMouseLeave","onMouseUp","row","extraClassName","id","className","onMouseDown","Component","dijkstra","grid","startNode","finishNode","distance","unvisitedNodes","nodes","node","push","getAllNodes","orderedVisitedNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbours","sort","nodeA","nodeB","unvisitedNeighbours","neighbours","filter","neighbour","getUnvisitedNeighbours","unvisited","previousNode","aStar","openSet","closedSet","g_cost","Math","sqrt","h_cost","f_cost","calcF","winner","forEach","index","currentNode","arr","i","splice","removeFromArray","console","log","includes","getNeighbours","neigh","tentative_g_score","heuristic","current","target","abs","randomGenerator","PathfinderVisualizer","state","mouseIsPressed","startNodeIsPressed","finishNodeIsPressed","isVisualizing","visualizationBeenReset","getInitialGrid","setState","handleMousePressforStart","handleMousePressforFinish","newGrid","toggleWallResetGrid","handleMouseEnterWithStart","handleMouseEnterWithFinish","toggleStartResetGrid","toggleFinishResetGrid","visitedNodesInOrder","nodesInShortestPathOrder","setTimeout","animateShortestPath","document","getElementById","getStartNode","alert","visualizersBeenReset","getFinishNode","minorResetGrid","nodesInShortestPath","unshift","orderedShortestPath","animateDijkstra","orderedAStarPath","animateAStar","class","href","title","onClick","resetGrid","type","visualizeDijkstra","visualizeAStar","toggleObstacles","map","rowIdx","key","nodeIdx","handleMousePress","handleMouseEnter","handleMouseLeave","handleStop","createNode","f_score","g_score","h_score","currentRow","newNode","random","slice","App","Boolean","window","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.0c651913.chunk.js","sourcesContent":["import React, {Component} from 'react';\nimport './Node.scss';\n\nexport default class Node extends Component {\n  render() {\n    const {\n      col,\n      isFinish,\n      isStart,\n      isWall,\n      whileMousePressed,\n      onMouseEnter,\n      onMouseLeave,\n      onMouseUp,\n      row,\n    } = this.props;\n    const extraClassName = \n      isFinish\n      ? 'node-finish'\n      : isStart\n      ? 'node-start'\n      : isWall\n      ? 'node-wall'\n      : '';\n\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName}`}\n        onMouseDown={() => whileMousePressed(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseLeave={() => onMouseLeave(row, col)}\n        onMouseUp={() => onMouseUp(row, col)}>\n        </div>\n    );\n  }\n}","//Uses Djikstra's algorithm to determine the shortest path\n//Returns all the nodes in the order they were visited\n//Basically, the nodes point to the previous neighbouring node\n//that was visited, enabling calculation of the shortest path \n//between start point and end point\n\nexport function dijkstra(grid, startNode, finishNode) {\n    startNode.distance = 0;\n    const unvisitedNodes = getAllNodes(grid);\n    const orderedVisitedNodes = [];\n    while(!!unvisitedNodes.length) {\n        sortNodesByDistance(unvisitedNodes);\n        const closestNode = unvisitedNodes.shift(); //update closest node\n        if (closestNode.isWall) continue; //skip obstacle nodes\n        if (closestNode.distance === Infinity) return orderedVisitedNodes; //When there is no solution\n        closestNode.isVisited = true; //Mark node as visited\n        if (closestNode === finishNode) return orderedVisitedNodes; //On completion of path determination\n        orderedVisitedNodes.push(closestNode); //Add the latest visited node to the visited list\n        updateUnvisitedNeighbours(closestNode, grid); \n    }\n}\n\n/**\n * Function to get all the nodes in grid and their coordinates\n */\nfunction getAllNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n        for (const node of row) {\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}\n\n/**\n * Function to sort nodes based on their coordinates\n */\nfunction sortNodesByDistance(unvisitedNodes) {\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\n/**\n * Function to update the distance of the neighbours to the current node\n * and mark the node it originated from for each\n */\nfunction updateUnvisitedNeighbours (node, grid){\n    const unvisitedNeighbours = getUnvisitedNeighbours(node, grid);\n    for (const unvisited of unvisitedNeighbours){\n        unvisited.distance = node.distance + 1;\n        unvisited.previousNode = node;\n    }\n}\n\n/**\n * Function to get the surrounding neighbours of the current node that haven't been visited\n */\nfunction getUnvisitedNeighbours (node, grid) {\n    const neighbours = [];\n    const {col, row} = node;\n    if (col < grid[0].length-1) neighbours.push(grid[row][col+1]); //get right neighbour\n    if (row < grid.length-1) neighbours.push(grid[row+1][col]); //get lower neighbour\n    if (row > 0) neighbours.push(grid[row - 1][col]); //get upper neighbour\n    if (col > 0) neighbours.push(grid[row][col-1]); //get left neighbour\n\n    // if (col < grid[0].length-1 && row < grid.length-1) neighbours.push(grid[row+1][col+1]); //get right neighbour\n    // if (col > 0  &&  row < grid.length-1) neighbours.push(grid[row+1][col-1]); //get lower neighbour\n    // if (col > 0 && row > 0) neighbours.push(grid[row - 1][col-1]); //get upper neighbour\n    // if (col < grid[0].length-1 && row > 0)neighbours.push(grid[row-1][col+1]); //get left neighbour\n    return neighbours.filter(neighbour=> !neighbour.isVisited); //return array of neighbour nodes that havent been visited\n}\n\n/**\n * Function to organize the nodes that draw out the shortest path\n */\nexport function orderedShortestPath (finishNode){\n    const nodesInShortestPath = [];\n    let currentNode = finishNode; //setup initial node as the final node\n    while (currentNode!== null){ //while current node isn't start node\n        nodesInShortestPath.unshift(currentNode); //keep adding current node to front of array\n        currentNode = currentNode.previousNode; //update currentNode\n    }\n    return nodesInShortestPath;\n}","\n/**\n * Uses A* algorithm to determine the shortest path\n * Returns all the nodes in the order they were visited\n * Basically, the nodes point to the previous neighbouring node\n * that was visited, enabling calculation of the shortest path \n * between start point and end point\n */\n\n\n//Open set - list containing nodes to be evaluated. Usually neighbouring nodes to current node that haven't been evaluated, not all the nodes in grid\n//Closed set - list containing all nodes that have already been evaluated\n//g_cost - distance between current node and start node\n//h_cost - distance between current node and finish node\n//f_cost - sum of g_cost and f_cost\n//Algorithm considered finished once all nodes that can possibly be evaluated have been evaluated or you've found the end node\n\nexport function aStar( grid, startNode, finishNode) {\n    const openSet = [];\n    const closedSet = [];\n    \n    openSet.push(startNode); //add startNode to openSet\n    calcF(startNode, finishNode, startNode);\n\n    //keep looping as long as openSet's greater than 0\n    while(openSet.length > 0) {\n        \n        //determine the node with the lowest f_cost and set it as currentNode\n        let winner = 0;\n        openSet.forEach((node, index) => {\n            if(node.f_cost < openSet[winner].f_cost){\n                winner = index;\n            }\n        });\n        let currentNode = openSet[winner];\n        //remove currentNode from openSet and add it to closedSet\n        removeFromArray(openSet, currentNode);\n        closedSet.push(currentNode);\n        //if currentNode is finishNode, solution found, reconstruct path\n        if (currentNode === finishNode) {\n            console.log(\"Done\");\n            return closedSet;\n        }\n\n\n\n        let neighbours = getNeighbours(currentNode, grid, closedSet);\n\n        neighbours.forEach(neigh => {\n            if(!closedSet.includes(neigh) && !neigh.isWall){\n                let tentative_g_score = currentNode.g_cost + heuristic(neigh, currentNode);\n                if(!openSet.includes(neigh)){\n                    openSet.push(neigh);\n                } \n                else if (tentative_g_score >= neigh.g_cost){\n                    neigh.g_cost = tentative_g_score;\n                }\n\n                neigh.g_cost = tentative_g_score;\n                neigh.h_cost = heuristic(neigh, finishNode);\n                neigh.f_cost = neigh.g_cost +  neigh.h_cost;\n                neigh.previousNode = currentNode;\n            }\n        });\n    }\n    return closedSet;\n}\n\nfunction removeFromArray(arr, node){\n    for( var i = arr.length-1; i >= 0; i--){\n        if (arr[i] === node){\n            arr.splice(i, 1);\n        }\n    }\n}\n\n/**\n * Get the heiristic between point a and d\n */\nfunction heuristic(current, target) {\n    // return Math.sqrt( (current.col-target.col)**2 + (current.row-target.row)**2);\n    return (Math.abs(current.col-target.col) + (Math.abs(current.row - target.row)));\n}\n/**\n * Function to assign nodes with their costs\n */\nfunction calcF(startNode, finishNode, node) {\n    node.g_cost = Math.sqrt( (node.col-startNode.col)**2 + (node.row-startNode.row)**2);\n    node.h_cost = Math.sqrt( (node.col-finishNode.col)**2 + (node.row-finishNode.row)**2);\n    node.f_cost = node.g_cost + node.h_cost;\n}\n\n/**\n * Function to get the node with minimum f_cost\n */\n// function getMinFcost(openSet){\n//     return openSet.reduce((min, node) => node.f_cost < min ? node.f_cost : min, openSet[0]);\n// }\n\n\n\n/**\n * Function to get the surrounding neighbours of the current node that haven't been visited\n */\nfunction getNeighbours (node, grid, closedSet) {\n    const neighbours = [];\n    const {col, row} = node;\n    if (col < grid[0].length-1) neighbours.push(grid[row][col+1]); //get right neighbour\n    if (row < grid.length-1) neighbours.push(grid[row+1][col]); //get lower neighbour\n    if (row > 0) neighbours.push(grid[row - 1][col]); //get upper neighbour\n    if (col > 0) neighbours.push(grid[row][col-1]); //get left neighbour\n\n    // if (col < grid[0].length-1 && row < grid.length-1) neighbours.push(grid[row+1][col+1]); //get right neighbour\n    // if (col > 0  &&  row < grid.length-1) neighbours.push(grid[row+1][col-1]); //get lower neighbour\n    // if (col > 0 && row > 0) neighbours.push(grid[row - 1][col-1]); //get upper neighbour\n    // if (col < grid[0].length-1 && row > 0)neighbours.push(grid[row-1][col+1]); //get left neighbour\n    return neighbours.filter(neighbour=> !closedSet.includes(neighbour)); //return array of neighbour nodes that havent been visited\n}\n\n/**\n * Function to organize the nodes that draw out the shortest path\n */\nexport function orderedAStarPath (finishNode){\n    const nodesInShortestPath = [];\n    let currentNode = finishNode; //setup initial node as the final node\n    while (currentNode!== null){ //while current node isn't start node\n        nodesInShortestPath.unshift(currentNode); //keep adding current node to front of array\n        currentNode = currentNode.previousNode; //update currentNode\n    }\n    return nodesInShortestPath;\n}","import React, {Component} from 'react';\nimport Node from './Node/Node';\nimport './PathfinderVisualizer.scss';\nimport {dijkstra, orderedShortestPath} from '../Algorithms/Dijkstras';\nimport { aStar, orderedAStarPath } from '../Algorithms/A_star';\n\nconst START_NODE_ROW = 11;\nconst START_NODE_COL = 10;\nconst FINISH_NODE_ROW = 11;\nconst FINISH_NODE_COL = 50;\nconst ROW_NUMBER = 20;\nconst COLUMN_NUMBER = 52;\n\nlet randomGenerator = false;\nlet defaultRandomWallGenerator = 0.15;\n\nexport default class PathfinderVisualizer extends Component {\n  constructor(){\n    super();\n    this.state = {\n      grid: [],\n      mouseIsPressed: false,\n      startNodeIsPressed: false,\n      finishNodeIsPressed: false,\n      isVisualizing: false,\n      visualizationBeenReset: true,\n    };\n  }\n\n  /**\n   * Function called on init, so as to create 2D grid layout with start and finish node set\n   */\n  componentDidMount() {\n    const grid = getInitialGrid();\n    this.setState({grid});\n  }\n  \n  /**\n   * Function to handle when mouse is clicked at node, so as to start making or make particular node an obstacle\n   */\n  handleMousePress(row, col){\n    if (!this.state.visualizationBeenReset) return;\n    if (this.state.isVisualizing) return;\n\n    if (this.state.grid[row][col].isStart){\n      this.handleMousePressforStart(row, col);\n      return;\n    } else if(this.state.grid[row][col].isFinish){\n      this.handleMousePressforFinish(row, col);\n      return;\n    }\n    const newGrid = toggleWallResetGrid(this.state.grid, row, col);\n    this.setState({grid: newGrid, mouseIsPressed: true});\n  }\n\n  /**\n   * Function to handle when mouse enters node while pressed, so as to make node an obstacle\n   */\n  handleMouseEnter(row, col){\n    if (!this.state.visualizationBeenReset) return;\n    if (this.state.isVisualizing) return;\n    if ((!this.state.mouseIsPressed) && (!this.state.startNodeIsPressed) && (!this.state.finishNodeIsPressed)) return; //if not pressed already, don't do anything\n    if(this.state.startNodeIsPressed){\n      this.handleMouseEnterWithStart(row, col);\n      return;\n    } \n    else if(this.state.finishNodeIsPressed){\n      this.handleMouseEnterWithFinish(row, col);\n      return;    \n    }\n    else {\n      const newGrid = toggleWallResetGrid(this.state.grid, row, col);\n      this.setState({grid: newGrid});\n    }\n  }\n\n  /**\n   * Function to handle when user stops holding down mouse for obstacle creation, so s to stop making walls\n   */\n  handleStop(row, col){\n    if (!this.state.visualizationBeenReset) return;\n    if (this.state.isVisualizing) return;\n    this.setState({mouseIsPressed: false});\n    this.setState({startNodeIsPressed: false});\n    this.setState({finishNodeIsPressed: false});\n  }\n\n  /**\n   * Function to handle when mouse is clicked on start, note that it is start pressed - prep to hold it\n   */\n  handleMousePressforStart(row, col){\n      this.setState({startNodeIsPressed: true});\n  }\n  /**\n   * Function to handle when mouse is clicked on finish, note that it is start pressed - prep to hold it\n   */\n  handleMousePressforFinish(row, col){\n    this.setState({finishNodeIsPressed: true});\n  }\n\n  /**\n   * When mouse enters node while pressed  (holding the start node), make node wall\n   */\n  handleMouseEnterWithStart(row, col){\n    if (!this.state.startNodeIsPressed) return; //if start not pressed already, don't do anything\n    const newGrid = toggleStartResetGrid(this.state.grid, row, col);\n    this.setState({grid: newGrid});\n  }\n\n  /**\n   * Function to handle when mouse enters node while pressed (holding the finish node), make node wall\n   */\n  handleMouseEnterWithFinish(row, col){\n    if (!this.state.finishNodeIsPressed) return; //if finish not pressed already, don't do anything\n    const newGrid = toggleFinishResetGrid(this.state.grid, row, col);\n    this.setState({grid: newGrid});\n  } \n\n  /**\n   * Function to handle when mouse leaves node while pressed, make node wall\n   */\n  handleMouseLeave(row, col){\n    if ((!this.state.startNodeIsPressed) && (!this.state.finishNodeIsPressed)) return; //if not pressed already, don't do anything\n    let newGrid;\n    if(this.state.startNodeIsPressed){\n      newGrid = toggleStartResetGrid(this.state.grid, row, col);\n    } \n    else if(this.state.finishNodeIsPressed){\n      newGrid = toggleFinishResetGrid(this.state.grid, row, col);\n    }\n    this.setState({grid: newGrid});\n  }\n\n  /**\n   * Function to get current startNode coordinates for visualization\n   */\n  getStartNode(){\n    const {grid} = this.state;\n    let startNode =grid[START_NODE_ROW][START_NODE_COL];\n    grid.forEach(function(row){\n      for (let i = 0; i < row.length; i++){\n        let node = (row[i]);\n        if (node.isStart){\n          startNode = node;;\n        }\n      }\n    });\n    return startNode;\n  }\n\n    /**\n   * Function to get current finishNode coordinates for visualization\n   */\n  getFinishNode(){\n    const {grid} = this.state;\n    let finishNode =grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    grid.forEach(function(row){\n      for (let i = 0; i < row.length; i++){\n        let node = (row[i]);\n        if (node.isFinish){\n          finishNode = node;;\n        }\n      }\n    });\n    return finishNode;\n  }\n\n  /**\n   * Function to enable visualization of Dijkstra's Algorithm in play\n   */\n  animateDijkstra (visitedNodesInOrder, nodesInShortestPathOrder){\n    for (let i = 0; i <= visitedNodesInOrder.length-1; i++) {\n      if (i === visitedNodesInOrder.length-1) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 3 * i);\n        return;\n      }    \n      setTimeout(()=>{\n        const node = visitedNodesInOrder[i];\n        if (!node.isStart) document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited';\n      }, 2 * i);\n    }    \n  }\n\n  /**\n   * Function to enable visualization of result ie shortest path found\n   */\n  animateShortestPath(nodesInShortestPathOrder) {\n    if(nodesInShortestPathOrder[0] !== this.getStartNode()){\n      console.log('No path available');\n      alert('No path available');\n      this.setState({isVisualizing: false});\n      this.setState({visualizersBeenReset: false});\n      return;\n    }\n    for (let i = 1; i < nodesInShortestPathOrder.length-1; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path';\n      }, 50 * i);\n    }\n    this.setState({isVisualizing: false});\n    this.setState({visualizationBeenReset: true});\n  }\n\n\n\n  /**\n   * Function to initiate visualization of Dijkstra's Algorithm\n   */\n  visualizeDijkstra() {\n    const {grid} = this.state;\n    const startNode = this.getStartNode();\n    const finishNode = this.getFinishNode();\n    this.minorResetGrid(grid);\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = orderedShortestPath(finishNode);\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n    this.setState({isVisualizing: true});\n    this.setState({visualizationBeenReset: false});\n  }\n\n    /**\n   * Function to initiate visualization of Dijkstra's Algorithm\n   */\n  visualizeAStar() {\n    const {grid} = this.state;\n    const startNode = this.getStartNode();\n    const finishNode = this.getFinishNode();\n    this.minorResetGrid(grid);\n    const visitedNodesInOrder = aStar(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = orderedAStarPath(finishNode);\n    this.animateAStar(visitedNodesInOrder, nodesInShortestPathOrder);\n    this.setState({isVisualizing: true});\n    this.setState({visualizationBeenReset: false});\n  }\n  animateAStar (visitedNodesInOrder, nodesInShortestPathOrder){\n    for (let i = 0; i <= visitedNodesInOrder.length-1; i++) { \n      if (i === visitedNodesInOrder.length-1) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 3 * i);\n        return;\n      }  \n      setTimeout(()=>{\n        const node = visitedNodesInOrder[i];\n        if (!node.isStart) document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited';\n      }, 3 * i);\n    }    \n  }\n\n  /**\n   * Function that changes the obstacke setup\n   */\n  /*changeObstacles(){\n    if (this.state.isVisualizing) return;\n    // if (!this.state.visualizationBeenReset) return;\n    randomGenerator = true;\n    const grid = getInitialGrid();\n    this.setState({grid});\n    this.minorResetGrid(grid);\n    this.setState({visualizationBeenReset: true});\n  }*/\n\n  /**\n   * Function that generates Random Obstacle SetUp given a particular obstacle density\n   */\n  /*changeDensity(density){\n    if (this.state.isVisualizing) return;\n    // if (!this.state.visualizationBeenReset) return;\n    randomGenerator = true;\n    defaultRandomWallGenerator = density;\n    const grid = getInitialGrid();\n    this.setState({grid});\n    this.minorResetGrid(grid);\n    this.setState({visualizationBeenReset: true});\n\n  }*/\n  /**\n   * Function to show or hide obstacles On or Off\n   */\n  toggleObstacles(){\n    if (this.state.isVisualizing) return;\n    // if (!this.state.visualizationBeenReset) return;\n    randomGenerator = !randomGenerator;\n    const grid = getInitialGrid();\n    this.setState({grid});\n    this.minorResetGrid(grid);\n    this.setState({visualizationBeenReset: true});\n  }\n\n  resetGrid(){\n    if (this.state.isVisualizing) return;\n    // if (!this.state.visualizationBeenReset) return;\n    this.setState({isVisualizing: false});\n    const grid = getInitialGrid();\n    this.setState({grid});\n    grid.forEach(function(row){\n      for (let i = 0; i < row.length; i++){\n        let node = (row[i]);\n        if (!node.isStart && !node.isFinish && !node.isWall){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node';\n        }\n      }\n    });\n    this.setState({visualizationBeenReset: true});\n  }\n\n  minorResetGrid(grid){\n    if (this.state.isVisualizing) return;\n    grid.forEach(function(row){\n      for (let i = 0; i < row.length; i++){\n        let node = (row[i]);\n        if (!node.isStart && !node.isFinish && !node.isWall){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node';\n        }\n      }\n    });\n  }\n\n  render(){\n    const {grid, mouseIsPressed, startNodeIsPressed, finishNodeIsPressed} = this.state;\n    const isVisualizing = this.state.isVisualizing;\n\n    return (\n      <div>\n        <div id=\"openModal-about\" class=\"modalDialog\">\n            <div>\n              <a href=\"#saka\" title=\"Close\" className=\"close\">X</a>\n              <div class=\"cPanelContainer\">\n\n<div className=\"cPanelHeader\">\n  <h1>Welcome to PathFinder</h1>\n  <span>A pathfinding algorithm seeks to find the shortest path between two points.</span> <br/>\n  <span>This application visualizes various pathfinding algorithms in action on a 2D grid.</span>\n\n<h3>Instruction Guide</h3> \n<hr/>\n<p>You can visualize of one of two algorithms:</p>\n<ul>\n<p> - &nbsp;<span>Dijkstra's Algorithm</span>  &nbsp; - &nbsp; The father of pathfinding algorithms; guarantees the shortest path</p>\n<p> - &nbsp;<span>A*'s Algorithm</span>  &nbsp; - &nbsp; Uses heuristics to guarantee the shortest path much faster than Dijkstra's</p>\n</ul> \n<hr/>\n<p>You can add obstacles to the grid through multiple ways:</p>\n<ul>\n<p> - &nbsp;<span>Toggle</span>  &nbsp; - &nbsp; You can toggle obstacles on or off</p>\n<p> - &nbsp;<span>Draw obstacles</span>  &nbsp; - &nbsp;  You can click or click and drag to generate obstacles with the pointer</p>\n</ul> \n\n<h3>Application Key</h3> \n<hr/>\n<ul>\n<p> - &nbsp;<span>Nodes</span>  &nbsp; - &nbsp; A point in the grid</p>\n<p> - &nbsp;<span>Navy blue nodes</span>  &nbsp; - &nbsp; Obstacles</p>\n<p> - &nbsp;<span>White nodes</span> &nbsp; - Unvisited</p>\n<p> - &nbsp;<span>Blue nodes</span>  &nbsp; - &nbsp; Visited nodes</p>\n<p> - &nbsp;<span>Yellow nodes</span>  &nbsp; - &nbsp; Shows final path</p>\n<p> - &nbsp;<span>Green node</span>  &nbsp; - &nbsp; Starting point</p>\n<p> - &nbsp;<span>Red node</span>  &nbsp; - &nbsp; End point</p>\n<p> <b><span>Note</span>  &nbsp; - &nbsp;You can drag the start point (in green) and endpoint (in red) to your desired position</b></p>\n\n</ul> \n</div>\n\n<div className=\"cPanelFooter\">\n  <span>\n    For more information of the algorithms, check them out on the following links:\n  </span>\n  \n<p><a href=\"https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\">Dijkstra's Algorithm</a> </p>\n<p> <a href=\"https://en.wikipedia.org/wiki/A*_search_algorithm\">A* Algorithm</a> </p>\n\n</div>\n\n</div>\n            </div>\n        </div>\n        <nav>\n        <div className=\"logo\" onClick={() => this.resetGrid()}>\n        PATH  <br/> FINDER \n        </div>\n        <ul className=\"nav-links\">{isVisualizing \n        ? <div>\n          <div className=\"spinner\"> \n          <span></span><span></span><span></span>\n          </div>\n          <div className=\"label\">Visualizing</div>\n      </div>\n      \n        : <ul className=\"nav-links\">\n          <label className=\"dropdown\">\n              <div className=\"dd-button\">\n              Visualize\n              </div>\n              <input type=\"checkbox\" className=\"dd-input\" id=\"test\"></input>\n              <ul className=\"dd-menu\">\n                <li onClick={() => this.visualizeDijkstra()}>Dijkstra's Algorithm</li>\n                <li onClick={() => this.visualizeAStar()}>A* Algorithm</li>\n              </ul>\n            </label>\n            <li onClick={() => this.resetGrid()}>Reset Grid</li>\n            <li onClick={() => this.toggleObstacles()}>Toggle Obstacles</li>  \n            \n            <li> <a href=\"#openModal-about\">App Info</a> </li>  \n\n          </ul>\n      }</ul> <br/> \n\n      </nav>     \n\n        {/* Render the 2D grid layout */}\n        <div className=\"grid align-middle\">\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const {row, col, isFinish, isStart, isWall} = node;\n                  return (\n                    <Node\n                      key={nodeIdx}\n                      col={col}\n                      isFinish={isFinish}\n                      isStart={isStart}\n                      isWall={isWall}\n                      mouseIsPressed={mouseIsPressed}\n                      startNodeIsPressed={startNodeIsPressed}\n                      finishNodeIsPressed={finishNodeIsPressed}\n                      whileMousePressed={(row, col) => this.handleMousePress(row, col)}\n                      onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}   \n                      onMouseLeave={(row, col) => this.handleMouseLeave(row, col)}   \n                      onMouseUp={()=> this.handleStop(row, col)}                \n                      row={row}>\n                    </Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n      </div>\n    );\n  }\n}\n\n/**\n * function to setup nodes and default position of startpoint and endpoint\n */\nconst createNode = (col, row) => {\n  return {\n    col,\n    row,\n    distance: Infinity,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    isWall: false,\n    isVisited: false,\n    previousNode: null,\n    f_score: Infinity,\n    g_score: Infinity,\n    h_score: Infinity,\n  };\n};\n\n/**\n * function to setup 2D grid layout\n */\nconst getInitialGrid = () => {\n  const grid = [];\n  for (let row = 0; row <ROW_NUMBER; row++) {\n    const currentRow = [];\n    for (let col = 0; col < COLUMN_NUMBER; col++) {\n      let newNode =createNode(col, row);\n      //Random wall generator\n      if (randomGenerator){\n          if (Math.random(1) < defaultRandomWallGenerator){\n            newNode.isWall = true;\n        }\n      }\n      currentRow.push(newNode);\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\n/**\n * function to make a node a wall\n */\nconst toggleWallResetGrid = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWall: !node.isWall,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n}\n\n/**\n * function to make a node a startPoint or remove it as a startPoint\n */\nconst toggleStartResetGrid = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isStart: !node.isStart,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n}\n\n/**\n * function to make a node a endPoint or remove it as a startPoint\n */\nconst toggleFinishResetGrid = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isFinish: !node.isFinish,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n}","import React from 'react';\nimport './App.css';\nimport PathfinderVisualizer from './PathfinderVisualizer/PathfinderVisualizer';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfinderVisualizer></PathfinderVisualizer>\n    </div>\n  );\n}\n\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n// import 'bootstrap/dist/css/bootstrap.min.css';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();"],"sourceRoot":""}